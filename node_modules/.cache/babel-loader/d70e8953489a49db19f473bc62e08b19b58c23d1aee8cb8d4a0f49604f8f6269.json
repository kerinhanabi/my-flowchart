{"ast":null,"code":"import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, resolveComponent as _resolveComponent, createBlock as _createBlock } from \"vue\";\nconst _hoisted_1 = [\"height\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_flowchart_link = _resolveComponent(\"flowchart-link\");\n  const _component_flowchart_node = _resolveComponent(\"flowchart-node\");\n  return _openBlock(), _createElementBlock(\"div\", {\n    class: \"flowchart-container\",\n    onMousemove: _cache[0] || (_cache[0] = (...args) => $options.handleMove && $options.handleMove(...args)),\n    onMouseup: _cache[1] || (_cache[1] = (...args) => $options.handleUp && $options.handleUp(...args)),\n    onMousedown: _cache[2] || (_cache[2] = (...args) => $options.handleDown && $options.handleDown(...args))\n  }, [(_openBlock(), _createElementBlock(\"svg\", {\n    width: \"100%\",\n    height: `${$props.height}px`\n  }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($options.lines, (link, index) => {\n    return _openBlock(), _createBlock(_component_flowchart_link, {\n      link: link,\n      key: `link${index}`,\n      onDeleteLink: $event => $options.linkDelete(link.id)\n    }, null, 8 /* PROPS */, [\"link\", \"onDeleteLink\"]);\n  }), 128 /* KEYED_FRAGMENT */))], 8 /* PROPS */, _hoisted_1)), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList($props.scene.nodes, (node, index) => {\n    return _openBlock(), _createBlock(_component_flowchart_node, {\n      key: `node${index}`,\n      node: node,\n      options: $options.nodeOptions,\n      x: node.x,\n      y: node.y,\n      onLinkingStart: $event => $options.linkingStart(node.id),\n      onLinkingStop: $event => $options.linkingStop(node.id),\n      onNodeSelected: $event => $options.nodeSelected(node.id, $event),\n      onNodeDelete: $event => $options.nodeDelete(node.id)\n    }, null, 8 /* PROPS */, [\"node\", \"options\", \"x\", \"y\", \"onLinkingStart\", \"onLinkingStop\", \"onNodeSelected\", \"onNodeDelete\"]);\n  }), 128 /* KEYED_FRAGMENT */))], 32 /* NEED_HYDRATION */);\n}","map":{"version":3,"names":["_createElementBlock","class","onMousemove","_cache","args","$options","handleMove","onMouseup","handleUp","onMousedown","handleDown","width","height","$props","_Fragment","_renderList","lines","link","index","_createBlock","_component_flowchart_link","key","onDeleteLink","$event","linkDelete","id","_hoisted_1","scene","nodes","node","_component_flowchart_node","options","nodeOptions","x","y","onLinkingStart","linkingStart","onLinkingStop","linkingStop","onNodeSelected","nodeSelected","onNodeDelete","nodeDelete"],"sources":["/Users/kerinwong/Documents/VSCode_tutorial/my-simple-flowchart/src/components/SimpleFlowchart.vue"],"sourcesContent":["<template>\n    <div class=\"flowchart-container\" \n        @mousemove=\"handleMove\" \n        @mouseup=\"handleUp\"\n        @mousedown=\"handleDown\">\n        <svg width=\"100%\" :height=\"`${height}px`\">\n        <flowchart-link :link=\"link\" \n            v-for=\"(link, index) in lines\" \n            :key=\"`link${index}`\"\n            @deleteLink=\"linkDelete(link.id)\">\n        </flowchart-link>\n        </svg>\n\n        <flowchart-node\n        v-for=\"(node, index) in scene.nodes\" \n        :key=\"`node${index}`\" \n        :node=\"node\" \n        :options=\"nodeOptions\"\n        :x=\"node.x\" :y=\"node.y\"\n        @linkingStart=\"linkingStart(node.id)\" \n        @linkingStop=\"linkingStop(node.id)\" \n        @nodeSelected=\"nodeSelected(node.id, $event)\" \n        @nodeDelete=\"nodeDelete(node.id)\">\n        </flowchart-node>\n    </div>\n</template>\n\n<script>\nimport FlowchartLink from './FlowchartLink.vue';\nimport FlowchartNode from './FlowchartNode.vue';\nimport { getMousePosition } from '../assets/utility/position.js';\n\nexport default {\n    name: 'VueFlowchart',\n    props: {\n      scene: {\n          type: Object,\n          default() {\n              return {\n                  centerX: 1024,\n                  scale: 1,\n                  centerY: 140,\n                  nodes: [],\n                  links: [],\n                  x: Math.random() * 500,\n                  y: Math.random() * 500\n\n              }\n          }\n      },\n      height: {\n          type: Number,\n          default: 400,\n      },\n    },\n    data() {\n      return {\n        localScene: JSON.parse(JSON.stringify(this.scene)),\n\n        dragging: false,\n        currentNode: null,\n        offsetX: 0,\n        offsetY: 0,\n\n        action: {\n          linking: false,\n          dragging: false,\n          scrolling: false,\n          selected: 0,\n        },\n        mouse: {\n          x: 0,\n          y: 0,\n          lastX: 0,\n          lastY: 0,\n        },\n        draggingLink: null,\n        rootDivOffset: {\n          top: 0,\n          left: 0\n        },\n      };\n    },\n    components: {\n      FlowchartLink,\n      FlowchartNode,\n    },\n    computed: {\n      nodeOptions() {\n        return {\n          centerY: this.localScene.centerY,\n          centerX: this.localScene.centerX,\n          scale: this.localScene.scale,\n          offsetTop: this.rootDivOffset.top,\n          offsetLeft: this.rootDivOffset.left,\n          selected: this.action.selected,\n        }\n      },\n      lines() {\n        const lines = [];\n        this.localScene.links.forEach(link => {\n          const fromNode = this.localScene.nodes.find(node => node.id === link.from);\n          const toNode = this.localScene.nodes.find(node => node.id === link.to);\n          if (!fromNode || !toNode) {\n            console.error(`Nodes not found for link ${link.id}`);\n            return;\n          }\n          let x, y, cy, cx, ex, ey;\n          x = this.localScene.centerX + fromNode.x;\n          y = this.localScene.centerY + fromNode.y;\n          [cx, cy] = this.getPortPosition('bottom', x, y);\n          x = this.localScene.centerX + toNode.x;\n          y = this.localScene.centerY + toNode.y;\n          [ex, ey] = this.getPortPosition('top', x, y);\n          lines.push({ \n            start: [cx, cy], \n            end: [ex, ey],\n            id: link.id,\n          });\n        });\n        return lines;\n      },\n    },\n    mounted() {\n      this.rootDivOffset.top = this.$el ? this.$el.offsetTop : 0;\n      this.rootDivOffset.left = this.$el ? this.$el.offsetLeft : 0;\n      this.localScene.nodes.forEach(node => {\n        node.x = Math.random() * (this.$el.clientWidth - 80);\n        node.y = Math.random() * (this.height - 80);\n      });\n    },\n    methods: {\n      findNodeWithID(id) {\n        return this.localScene.nodes.find((item) => {\n            return id === item.id\n        })\n      },\n      getPortPosition(type, x, y) {\n        if (type === 'top') {\n          return [x + 40, y];\n        }\n        else if (type === 'bottom') {\n          return [x + 40, y + 80];\n        }\n      },\n      linkingStart(index) {\n        this.action.linking = true;\n        this.draggingLink = {\n          from: index,\n          mx: 0,\n          my: 0,\n        };\n      },\n      linkingStop(index) {\n        // add new Link\n        if (this.draggingLink && this.draggingLink.from !== index) {\n          // check link existence\n          const existed = this.localScene.links.find((link) => {\n            return link.from === this.draggingLink.from && link.to === index;\n          })\n          if (!existed) {\n            let maxID = Math.max(0, ...this.localScene.links.map((link) => {\n              return link.id\n            }))\n            const newLink = {\n              id: maxID + 1,\n              from: this.draggingLink.from,\n              to: index,\n            };\n            this.localScene.links.push(newLink)\n            this.$emit('linkAdded', newLink)\n          }\n        }\n        this.draggingLink = null\n      },\n      linkDelete(id) {\n        const deletedLink = this.localScene.links.find((item) => {\n            return item.id === id;\n        });\n        if (deletedLink) {\n          this.localScene.links = this.localScene.links.filter((item) => {\n              return item.id !== id;\n          });\n          this.$emit('linkBreak', deletedLink);\n        }\n      },\n      nodeSelected(id, e) {\n        this.action.dragging = id;\n        this.action.selected = id;\n        this.$emit('nodeClick', id);\n        this.mouse.lastX = e.pageX || e.clientX + document.documentElement.scrollLeft\n        this.mouse.lastY = e.pageY || e.clientY + document.documentElement.scrollTop\n                \n        const nodeIndex = this.localScene.nodes.findIndex(node => node.id === id);\n        if (nodeIndex !== -1) {\n          this.localScene.nodes[nodeIndex].visible = true;\n        }\n      },\n      handleMove(e) {\n        if (this.action.linking) {\n          [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n          [this.draggingLink.mx, this.draggingLink.my] = [this.mouse.x, this.mouse.y];\n        }\n        if (this.action.dragging) {\n          this.mouse.x = e.pageX || e.clientX + document.documentElement.scrollLeft\n          this.mouse.y = e.pageY || e.clientY + document.documentElement.scrollTop\n          let diffX = this.mouse.x - this.mouse.lastX;\n          let diffY = this.mouse.y - this.mouse.lastY;\n  \n          this.mouse.lastX = this.mouse.x;\n          this.mouse.lastY = this.mouse.y;\n          this.moveSelectedNode(diffX, diffY);\n        }\n        if (this.action.scrolling) {\n          [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n          let diffX = this.mouse.x - this.mouse.lastX;\n          let diffY = this.mouse.y - this.mouse.lastY;\n  \n          this.mouse.lastX = this.mouse.x;\n          this.mouse.lastY = this.mouse.y;\n  \n          this.localScene.centerX += diffX;\n          this.localScene.centerY += diffY;\n  \n          // this.hasDragged = true\n        }\n      },\n      handleUp(e) {\n        const target = e.target || e.srcElement;\n        if (this.$el.contains(target)) {\n          if (typeof target.className !== 'string' || target.className.indexOf('node-input') < 0) {\n            this.draggingLink = null;\n          }\n          if (typeof target.className === 'string' && target.className.indexOf('node-delete') > -1) {\n            // console.log('delete2', this.action.dragging);\n            this.nodeDelete(this.action.dragging);\n          }\n        }\n        this.action.linking = false;\n        this.action.dragging = null;\n        this.action.scrolling = false;\n      },\n      handleDown(e) {\n        const target = e.target || e.srcElement;\n        // console.log('for scroll', target, e.keyCode, e.which)\n        if ((target === this.$el || target.matches('svg, svg *')) && e.which === 1) {\n          this.action.scrolling = true;\n          [this.mouse.lastX, this.mouse.lastY] = getMousePosition(this.$el, e);\n          this.action.selected = null; // deselectAll\n        }\n        this.$emit('canvasClick', e);\n      },\n\n      moveSelectedNode(dx, dy) {\n        let index = this.localScene.nodes.findIndex((item) => {\n          return item.id === this.action.dragging\n        })\n        if (index !== -1) {\n          let left = this.localScene.nodes[index].x + dx / this.localScene.scale;\n          let top = this.localScene.nodes[index].y + dy / this.localScene.scale;\n          this.localScene.nodes[index] = Object.assign(this.localScene.nodes[index], {\n            x: left,\n            y: top,\n          });\n        }\n      },\n      nodeDelete(id) {\n        const nodeIndex = this.localScene.nodes.findIndex(node => node.id === id);\n        if (nodeIndex !== -1) {\n          this.localScene.nodes.splice(nodeIndex, 1);\n          this.$emit('nodeDelete', id);\n        }\n        this.localScene.nodes = this.localScene.nodes.filter((node) => {\n          return node.id !== id;\n        })\n        this.localScene.links = this.localScene.links.filter((link) => {\n          return link.from !== id && link.to !== id\n        })\n        this.$emit('nodeDelete', id)\n      },\n\n      handleMousedown(event) {\n        const id = event.target.dataset.id;\n        if (id) {\n          this.dragging = true;\n          this.currentNode = this.localScene.nodes.find((node) => node.id === parseInt(id));\n          this.offsetX = event.clientX - this.currentNode.x;\n          this.offsetY = event.clientY - this.currentNode.y;\n        }\n      },\n      handleMouseMove(event) {\n        if (this.dragging) {\n          this.currentNode.x = event.clientX - this.offsetX;\n          this.currentNode.y = event.clientY - this.offsetY;\n        }\n      },\n      handleMouseUp(event) {\n        console.log('Mouse up event triggered');\n        console.log('Node removed:', this.localScene.nodes);\n        this.dragging = false;\n        this.currentNode = null;\n        if (event.target.classList.contains('node-delete')) {\n          const id = event.target.parentNode.dataset.id;\n          this.localScene.nodes = this.localScene.nodes.filter((node) => node.id !== parseInt(id));\n          this.$emit('nodeDelete', id);\n        }\n      },\n\n    },\n  }\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped lang=\"scss\">\n.flowchart-container {\nmargin: 0;\nbackground: #ddd;\nposition: relative;\noverflow: hidden;\n    svg {\n        cursor: grab;\n    }\n}\n</style>"],"mappings":";mBAAA;;;;uBACIA,mBAAA,CAuBM;IAvBDC,KAAK,EAAC,qBAAqB;IAC3BC,WAAS,EAAAC,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAC,UAAA,IAAAD,QAAA,CAAAC,UAAA,IAAAF,IAAA,CAAU;IACrBG,SAAO,EAAAJ,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAG,QAAA,IAAAH,QAAA,CAAAG,QAAA,IAAAJ,IAAA,CAAQ;IACjBK,WAAS,EAAAN,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAK,UAAA,IAAAL,QAAA,CAAAK,UAAA,IAAAN,IAAA,CAAU;qBACtBJ,mBAAA,CAMM;IANDW,KAAK,EAAC,MAAM;IAAEC,MAAM,KAAKC,MAAA,CAAAD,MAAM;yBACpCZ,mBAAA,CAIiBc,SAAA,QAVzBC,WAAA,CAOoCV,QAAA,CAAAW,KAAK,EAPzC,CAOoBC,IAAI,EAAEC,KAAK;yBADvBC,YAAA,CAIiBC,yBAAA;MAJAH,IAAI,EAAEA,IAAI;MAEtBI,GAAG,SAASH,KAAK;MACjBI,YAAU,EAAAC,MAAA,IAAElB,QAAA,CAAAmB,UAAU,CAACP,IAAI,CAACQ,EAAE;;kDAT3CC,UAAA,K,kBAaQ1B,mBAAA,CAUiBc,SAAA,QAvBzBC,WAAA,CAcgCF,MAAA,CAAAc,KAAK,CAACC,KAAK,EAd3C,CAcgBC,IAAI,EAAEX,KAAK;yBADnBC,YAAA,CAUiBW,yBAAA;MARhBT,GAAG,SAASH,KAAK;MACjBW,IAAI,EAAEA,IAAI;MACVE,OAAO,EAAE1B,QAAA,CAAA2B,WAAW;MACpBC,CAAC,EAAEJ,IAAI,CAACI,CAAC;MAAGC,CAAC,EAAEL,IAAI,CAACK,CAAC;MACrBC,cAAY,EAAAZ,MAAA,IAAElB,QAAA,CAAA+B,YAAY,CAACP,IAAI,CAACJ,EAAE;MAClCY,aAAW,EAAAd,MAAA,IAAElB,QAAA,CAAAiC,WAAW,CAACT,IAAI,CAACJ,EAAE;MAChCc,cAAY,EAAAhB,MAAA,IAAElB,QAAA,CAAAmC,YAAY,CAACX,IAAI,CAACJ,EAAE,EAAEF,MAAM;MAC1CkB,YAAU,EAAAlB,MAAA,IAAElB,QAAA,CAAAqC,UAAU,CAACb,IAAI,CAACJ,EAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}