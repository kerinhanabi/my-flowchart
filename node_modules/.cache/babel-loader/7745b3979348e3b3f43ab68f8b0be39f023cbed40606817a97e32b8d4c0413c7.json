{"ast":null,"code":"import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, resolveComponent as _resolveComponent, createBlock as _createBlock } from \"vue\";\nconst _hoisted_1 = [\"height\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_flowchart_link = _resolveComponent(\"flowchart-link\");\n  const _component_flowchart_node = _resolveComponent(\"flowchart-node\");\n  return _openBlock(), _createElementBlock(\"div\", {\n    class: \"flowchart-container\",\n    onMousemove: _cache[0] || (_cache[0] = (...args) => $options.handleMove && $options.handleMove(...args)),\n    onMouseup: _cache[1] || (_cache[1] = (...args) => $options.handleUp && $options.handleUp(...args)),\n    onMousedown: _cache[2] || (_cache[2] = (...args) => $options.handleDown && $options.handleDown(...args))\n  }, [(_openBlock(), _createElementBlock(\"svg\", {\n    width: \"100%\",\n    height: `${_ctx.height}px`\n  }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($options.lines, (link, index) => {\n    return _openBlock(), _createBlock(_component_flowchart_link, {\n      link: link,\n      key: `link${index}`,\n      onDeleteLink: $event => $options.linkDelete(link.id)\n    }, null, 8 /* PROPS */, [\"link\", \"onDeleteLink\"]);\n  }), 128 /* KEYED_FRAGMENT */))], 8 /* PROPS */, _hoisted_1)), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.scene.nodes, (node, index) => {\n    return _openBlock(), _createBlock(_component_flowchart_node, {\n      node: node,\n      key: `node${index}`,\n      options: $options.nodeOptions,\n      onLinkingStart: $event => $options.linkingStart(node.id),\n      onLinkingStop: $event => $options.linkingStop(node.id),\n      onNodeSelected: $event => $options.nodeSelected(node.id, $event)\n    }, null, 8 /* PROPS */, [\"node\", \"options\", \"onLinkingStart\", \"onLinkingStop\", \"onNodeSelected\"]);\n  }), 128 /* KEYED_FRAGMENT */))], 32 /* NEED_HYDRATION */);\n}","map":{"version":3,"names":["_createElementBlock","class","onMousemove","_cache","args","$options","handleMove","onMouseup","handleUp","onMousedown","handleDown","width","height","_ctx","_Fragment","_renderList","lines","link","index","_createBlock","_component_flowchart_link","key","onDeleteLink","$event","linkDelete","id","_hoisted_1","scene","nodes","node","_component_flowchart_node","options","nodeOptions","onLinkingStart","linkingStart","onLinkingStop","linkingStop","onNodeSelected","nodeSelected"],"sources":["/Users/kerinwong/Documents/VSCode_tutorial/my-simple-flowchart/src/components/SimpleFlowchart.vue"],"sourcesContent":["<template>\n    <div class=\"flowchart-container\" \n        @mousemove=\"handleMove\" \n        @mouseup=\"handleUp\"\n        @mousedown=\"handleDown\">\n        <svg width=\"100%\" :height=\"`${height}px`\">\n        <flowchart-link :link=\"link\" \n            v-for=\"(link, index) in lines\" \n            :key=\"`link${index}`\"\n            @deleteLink=\"linkDelete(link.id)\">\n        </flowchart-link>\n        </svg>\n        <flowchart-node :node=\"node\" \n        v-for=\"(node, index) in scene.nodes\" \n        :key=\"`node${index}`\"\n        :options=\"nodeOptions\"\n        @linkingStart=\"linkingStart(node.id)\"\n        @linkingStop=\"linkingStop(node.id)\"\n        @nodeSelected=\"nodeSelected(node.id, $event)\">\n        </flowchart-node>\n    </div>\n</template>\n\n<script>\nimport FlowchartLink from './FlowchartLink.vue';\nimport FlowchartNode from './FlowchartNode.vue';\nimport { getMousePosition } from '../assets/utility/position.js';\nimport { ref } from 'vue';\n\n\nexport default {\n    name: 'VueFlowchart',\n    props: {\n    // scene: {\n    //     type: Object,\n    //     default() {\n    //         return {\n    //             centerX: 1024,\n    //             scale: 1,\n    //             centerY: 140,\n    //             nodes: [],\n    //             links: [],\n    //         }\n    //     }\n    // },\n    // height: {\n    //     type: Number,\n    //     default: 400,\n    // },\n    },\n    setup() {\n      const localScene = ref({\n        scene: {\n          type: Object,\n          default() {\n              return {\n                centerX: 1024,\n                scale: 1,\n                centerY: 140,\n                nodes: [],\n                links: [],\n              }\n          }\n        },\n        height: {\n            type: Number,\n            default: 400,\n        }\n    });\n\n    function moveSelectedNode(dx, dy) {\n      let index = localScene.value.nodes.findIndex((item) => {\n        return item.id === this.action.dragging\n      })\n      if (index > -1) {\n        localScene.value.nodes[index].x += dx\n        localScene.value.nodes[index].y += dy\n      }\n    }\n\n      return {\n        localScene,\n        moveSelectedNode\n      }\n    },\n    data() {\n      return {\n        localScene: JSON.parse(JSON.stringify(this.scene)),\n        //moveSelectedNode,\n        action: {\n          linking: false,\n          dragging: false,\n          scrolling: false,\n          selected: 0,\n        },\n        mouse: {\n          x: 0,\n          y: 0,\n          lastX: 0,\n          lastY: 0,\n        },\n        draggingLink: null,\n        rootDivOffset: {\n          top: 0,\n          left: 0\n        },\n      };\n    },\n    components: {\n      FlowchartLink,\n      FlowchartNode,\n    },\n    computed: {\n      nodeOptions() {\n        return {\n          centerY: this.localScene.centerY,\n          centerX: this.localScene.centerX,\n          scale: this.localScene.scale,\n          offsetTop: this.rootDivOffset.top,\n          offsetLeft: this.rootDivOffset.left,\n          selected: this.action.selected,\n        }\n      },\n      lines() {\n        const lines = this.localScene.links.map((link) => {\n          const fromNode = this.findNodeWithID(link.from)\n          const toNode = this.findNodeWithID(link.to)\n          let x, y, cy, cx, ex, ey;\n          x = this.localScene.centerX + fromNode.x;\n          y = this.localScene.centerY + fromNode.y;\n          [cx, cy] = this.getPortPosition('bottom', x, y);\n          x = this.localScene.centerX + toNode.x;\n          y = this.localScene.centerY + toNode.y;\n          [ex, ey] = this.getPortPosition('top', x, y);\n          return { \n            start: [cx, cy], \n            end: [ex, ey],\n            id: link.id,\n          };\n        })\n        if (this.draggingLink) {\n          let x, y, cy, cx;\n          const fromNode = this.findNodeWithID(this.draggingLink.from)\n          x = this.localScene.centerX + fromNode.x;\n          y = this.localScene.centerY + fromNode.y;\n          [cx, cy] = this.getPortPosition('bottom', x, y);\n          // push temp dragging link, mouse cursor postion = link end postion \n          lines.push({ \n            start: [cx, cy], \n            end: [this.draggingLink.mx, this.draggingLink.my],\n          })\n        }\n        return lines;\n      }\n    },\n    mounted() {\n      this.rootDivOffset.top = this.$el ? this.$el.offsetTop : 0;\n      this.rootDivOffset.left = this.$el ? this.$el.offsetLeft : 0;\n      this.localScene.nodes.forEach(node => {\n        node.x = Math.random() * (this.$el.clientWidth - 80);\n        node.y = Math.random() * (this.height - 80);\n      });\n      // console.log(22222, this.rootDivOffset);\n    },\n    methods: {\n      findNodeWithID(id) {\n        return this.localScene.nodes.find((item) => {\n            return id === item.id\n        })\n      },\n      getPortPosition(type, x, y) {\n        if (type === 'top') {\n          return [x + 40, y];\n        }\n        else if (type === 'bottom') {\n          return [x + 40, y + 80];\n        }\n      },\n      linkingStart(index) {\n        this.action.linking = true;\n        this.draggingLink = {\n          from: index,\n          mx: 0,\n          my: 0,\n        };\n      },\n      linkingStop(index) {\n        // add new Link\n        if (this.draggingLink && this.draggingLink.from !== index) {\n          // check link existence\n          const existed = this.localScene.links.find((link) => {\n            return link.from === this.draggingLink.from && link.to === index;\n          })\n          if (!existed) {\n            let maxID = Math.max(0, ...this.localScene.links.map((link) => {\n              return link.id\n            }))\n            const newLink = {\n              id: maxID + 1,\n              from: this.draggingLink.from,\n              to: index,\n            };\n            this.localScene.links.push(newLink)\n            this.$emit('linkAdded', newLink)\n          }\n        }\n        this.draggingLink = null\n      },\n      linkDelete(id) {\n        const deletedLink = this.localScene.links.find((item) => {\n            return item.id === id;\n        });\n        if (deletedLink) {\n          this.localScene.links = this.localScene.links.filter((item) => {\n              return item.id !== id;\n          });\n          this.$emit('linkBreak', deletedLink);\n        }\n      },\n      nodeSelected(id, e) {\n        this.action.dragging = id;\n        this.action.selected = id;\n        this.$emit('nodeClick', id);\n        this.mouse.lastX = e.pageX || e.clientX + document.documentElement.scrollLeft\n        this.mouse.lastY = e.pageY || e.clientY + document.documentElement.scrollTop\n                \n        this.$set(this.localScene.nodes, id, {\n          ...this.localScene.nodes.find(node => node.id === id),\n          visible: true,\n        })\n      },\n      handleMove(e) {\n        if (this.action.linking) {\n          [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n          [this.draggingLink.mx, this.draggingLink.my] = [this.mouse.x, this.mouse.y];\n        }\n        if (this.action.dragging) {\n          this.mouse.x = e.pageX || e.clientX + document.documentElement.scrollLeft\n          this.mouse.y = e.pageY || e.clientY + document.documentElement.scrollTop\n          let diffX = this.mouse.x - this.mouse.lastX;\n          let diffY = this.mouse.y - this.mouse.lastY;\n  \n          this.mouse.lastX = this.mouse.x;\n          this.mouse.lastY = this.mouse.y;\n          this.moveSelectedNode(diffX, diffY);\n        }\n        if (this.action.scrolling) {\n          [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n          let diffX = this.mouse.x - this.mouse.lastX;\n          let diffY = this.mouse.y - this.mouse.lastY;\n  \n          this.mouse.lastX = this.mouse.x;\n          this.mouse.lastY = this.mouse.y;\n  \n          this.localScene.centerX += diffX;\n          this.localScene.centerY += diffY;\n  \n          // this.hasDragged = true\n        }\n      },\n      handleUp(e) {\n        const target = e.target || e.srcElement;\n        if (this.$el.contains(target)) {\n          if (typeof target.className !== 'string' || target.className.indexOf('node-input') < 0) {\n            this.draggingLink = null;\n          }\n          if (typeof target.className === 'string' && target.className.indexOf('node-delete') > -1) {\n            // console.log('delete2', this.action.dragging);\n            this.nodeDelete(this.action.dragging);\n          }\n        }\n        this.action.linking = false;\n        this.action.dragging = null;\n        this.action.scrolling = false;\n      },\n      handleDown(e) {\n        const target = e.target || e.srcElement;\n        // console.log('for scroll', target, e.keyCode, e.which)\n        if ((target === this.$el || target.matches('svg, svg *')) && e.which === 1) {\n          this.action.scrolling = true;\n          [this.mouse.lastX, this.mouse.lastY] = getMousePosition(this.$el, e);\n          this.action.selected = null; // deselectAll\n        }\n        this.$emit('canvasClick', e);\n      },\n      moveSelectedNode(dx, dy) {\n        let index = this.localScene.nodes.findIndex((item) => {\n          return item.id === this.action.dragging\n        })\n        let left = this.localScene.nodes[index].x + dx / this.localScene.scale;\n        let top = this.localScene.nodes[index].y + dy / this.localScene.scale;\n        this.$set(this.localScene.nodes, index, Object.assign(this.localScene.nodes[index], {\n          x: left,\n          y: top,\n        }));\n      },\n      nodeDelete(id) {\n        this.localScene.nodes = this.localScene.nodes.filter((node) => {\n          return node.id !== id;\n        })\n        this.localScene.links = this.localScene.links.filter((link) => {\n          return link.from !== id && link.to !== id\n        })\n        this.$emit('nodeDelete', id)\n      }\n    },\n  }\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped lang=\"scss\">\n.flowchart-container {\nmargin: 0;\nbackground: #ddd;\nposition: relative;\noverflow: hidden;\n    svg {\n        cursor: grab;\n    }\n}\n</style>\n"],"mappings":";mBAAA;;;;uBACIA,mBAAA,CAmBM;IAnBDC,KAAK,EAAC,qBAAqB;IAC3BC,WAAS,EAAAC,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAC,UAAA,IAAAD,QAAA,CAAAC,UAAA,IAAAF,IAAA,CAAU;IACrBG,SAAO,EAAAJ,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAG,QAAA,IAAAH,QAAA,CAAAG,QAAA,IAAAJ,IAAA,CAAQ;IACjBK,WAAS,EAAAN,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAK,UAAA,IAAAL,QAAA,CAAAK,UAAA,IAAAN,IAAA,CAAU;qBACtBJ,mBAAA,CAMM;IANDW,KAAK,EAAC,MAAM;IAAEC,MAAM,KAAKC,IAAA,CAAAD,MAAM;yBACpCZ,mBAAA,CAIiBc,SAAA,QAVzBC,WAAA,CAOoCV,QAAA,CAAAW,KAAK,EAPzC,CAOoBC,IAAI,EAAEC,KAAK;yBADvBC,YAAA,CAIiBC,yBAAA;MAJAH,IAAI,EAAEA,IAAI;MAEtBI,GAAG,SAASH,KAAK;MACjBI,YAAU,EAAAC,MAAA,IAAElB,QAAA,CAAAmB,UAAU,CAACP,IAAI,CAACQ,EAAE;;kDAT3CC,UAAA,K,kBAYQ1B,mBAAA,CAOiBc,SAAA,QAnBzBC,WAAA,CAagCF,IAAA,CAAAc,KAAK,CAACC,KAAK,EAb3C,CAagBC,IAAI,EAAEX,KAAK;yBADnBC,YAAA,CAOiBW,yBAAA;MAPAD,IAAI,EAAEA,IAAI;MAE1BR,GAAG,SAASH,KAAK;MACjBa,OAAO,EAAE1B,QAAA,CAAA2B,WAAW;MACpBC,cAAY,EAAAV,MAAA,IAAElB,QAAA,CAAA6B,YAAY,CAACL,IAAI,CAACJ,EAAE;MAClCU,aAAW,EAAAZ,MAAA,IAAElB,QAAA,CAAA+B,WAAW,CAACP,IAAI,CAACJ,EAAE;MAChCY,cAAY,EAAAd,MAAA,IAAElB,QAAA,CAAAiC,YAAY,CAACT,IAAI,CAACJ,EAAE,EAAEF,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}