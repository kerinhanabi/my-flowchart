{"ast":null,"code":"import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, resolveComponent as _resolveComponent, createBlock as _createBlock } from \"vue\";\nconst _hoisted_1 = [\"height\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_flowchart_link = _resolveComponent(\"flowchart-link\");\n  const _component_flowchart_node = _resolveComponent(\"flowchart-node\");\n  return _openBlock(), _createElementBlock(\"div\", {\n    class: \"flowchart-container\",\n    onMousemove: _cache[0] || (_cache[0] = (...args) => $options.handleMove && $options.handleMove(...args)),\n    onMouseup: _cache[1] || (_cache[1] = (...args) => $options.handleUp && $options.handleUp(...args)),\n    onMousedown: _cache[2] || (_cache[2] = (...args) => $options.handleDown && $options.handleDown(...args))\n  }, [(_openBlock(), _createElementBlock(\"svg\", {\n    width: \"100%\",\n    height: `${$props.height}px`\n  }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($options.lines, (link, index) => {\n    return _openBlock(), _createBlock(_component_flowchart_link, {\n      link: link,\n      key: `link${index}`,\n      onDeleteLink: $event => $options.linkDelete(link.id)\n    }, null, 8 /* PROPS */, [\"link\", \"onDeleteLink\"]);\n  }), 128 /* KEYED_FRAGMENT */))], 8 /* PROPS */, _hoisted_1)), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList($props.scene.nodes, (node, index) => {\n    return _openBlock(), _createBlock(_component_flowchart_node, {\n      key: `node${index}`,\n      node: node,\n      options: $options.nodeOptions,\n      onLinkingStart: $event => $options.linkingStart(node.id),\n      onLinkingStop: $event => $options.linkingStop(node.id),\n      onNodeSelected: $event => $options.nodeSelected(node.id, $event)\n    }, null, 8 /* PROPS */, [\"node\", \"options\", \"onLinkingStart\", \"onLinkingStop\", \"onNodeSelected\"]);\n  }), 128 /* KEYED_FRAGMENT */))], 32 /* NEED_HYDRATION */);\n}","map":{"version":3,"names":["_createElementBlock","class","onMousemove","_cache","args","$options","handleMove","onMouseup","handleUp","onMousedown","handleDown","width","height","$props","_Fragment","_renderList","lines","link","index","_createBlock","_component_flowchart_link","key","onDeleteLink","$event","linkDelete","id","_hoisted_1","scene","nodes","node","_component_flowchart_node","options","nodeOptions","onLinkingStart","linkingStart","onLinkingStop","linkingStop","onNodeSelected","nodeSelected"],"sources":["/Users/kerinwong/Documents/VSCode_tutorial/my-simple-flowchart/src/components/SimpleFlowchart.vue"],"sourcesContent":["<template>\n    <div class=\"flowchart-container\" \n      @mousemove=\"handleMove\" \n      @mouseup=\"handleUp\"\n      @mousedown=\"handleDown\">\n      <svg width=\"100%\" :height=\"`${height}px`\">\n        <flowchart-link :link=\"link\"\n          v-for=\"(link, index) in lines\" \n          :key=\"`link${index}`\"\n          @deleteLink=\"linkDelete(link.id)\">\n        </flowchart-link>\n      </svg>\n      <flowchart-node v-for=\"(node, index) in scene.nodes\" \n        :key=\"`node${index}`\"\n        :node=\"node\" \n        :options=\"nodeOptions\"\n        @linkingStart=\"linkingStart(node.id)\"\n        @linkingStop=\"linkingStop(node.id)\"\n        @nodeSelected=\"nodeSelected(node.id, $event)\">\n      </flowchart-node>\n    </div>\n  </template>\n  \n  <script>\n  import FlowchartLink from './FlowchartLink.vue';\n  import FlowchartNode from './FlowchartNode.vue';\n  import { getMousePosition } from '../assets/utility/position.js';\n  \n  export default {\n    name: 'VueFlowchart',\n    props: {\n      scene: {\n        //scene: Object,\n        type: Object,\n        default() {\n          return {\n            centerX: 1024,\n            scale: 1,\n            centerY: 140,\n            nodes: [],\n            links: [],\n          }\n        }\n      },\n      height: {\n        type: Number,\n        default: 400,\n      },\n    },\n    data() {\n      return {\n        localScene: { ...this.scene }, // create a local copy of the props\n        action: {\n          linking: false,\n          dragging: false,\n          scrolling: false,\n          selected: 0,\n        },\n        mouse: {\n          x: 0,\n          y: 0,\n          lastX: 0,\n          lastY: 0,\n        },\n        draggingLink: null,\n        rootDivOffset: {\n          top: 0,\n          left: 0\n        },\n      };\n    },\n    components: {\n      FlowchartLink,\n      FlowchartNode,\n    },\n    computed: {\n      nodeOptions() {\n        return {\n          centerY: this.scene.centerY,\n          centerX: this.scene.centerX,\n          scale: this.scene.scale,\n          offsetTop: this.rootDivOffset.top,\n          offsetLeft: this.rootDivOffset.left,\n          selected: this.action.selected,\n        }\n      },\n      lines() {\n        const lines = this.scene.links.map((link) => {\n          const fromNode = this.findNodeWithID(link.from)\n          const toNode = this.findNodeWithID(link.to)\n          let x, y, cy, cx, ex, ey;\n          x = this.scene.centerX + fromNode.x;\n          y = this.scene.centerY + fromNode.y;\n          [cx, cy] = this.getPortPosition('bottom', x, y);\n          x = this.scene.centerX + toNode.x;\n          y = this.scene.centerY + toNode.y;\n          [ex, ey] = this.getPortPosition('top', x, y);\n          return { \n            start: [cx, cy], \n            end: [ex, ey],\n            id: link.id,\n          };\n        })\n        if (this.draggingLink) {\n          let x, y, cy, cx;\n          const fromNode = this.findNodeWithID(this.draggingLink.from)\n          x = this.scene.centerX + fromNode.x;\n          y = this.scene.centerY + fromNode.y;\n          [cx, cy] = this.getPortPosition('bottom', x, y);\n          // push temp dragging link, mouse cursor postion = link end postion \n          lines.push({ \n            start: [cx, cy], \n            end: [this.draggingLink.mx, this.draggingLink.my],\n          })\n        }\n        return lines;\n      },\n      localSceneCopy() {\n        return { ...this.scene } // create a local copy of the prop\n      }\n    },\n    mounted() {\n      this.rootDivOffset.top = this.$el ? this.$el.offsetTop : 0;\n      this.rootDivOffset.left = this.$el ? this.$el.offsetLeft : 0;\n      // console.log(22222, this.rootDivOffset);\n    },\n    methods: {\n      findNodeWithID(id) {\n        return this.scene.nodes.find((item) => {\n            return id === item.id\n        })\n      },\n      getPortPosition(type, x, y) {\n        if (type === 'top') {\n          return [x + 40, y];\n        }\n        else if (type === 'bottom') {\n          return [x + 40, y + 80];\n        }\n      },\n      linkingStart(index) {\n        this.action.linking = true;\n        this.draggingLink = {\n          from: index,\n          mx: 0,\n          my: 0,\n        };\n      },\n      linkingStop(index) {\n        const localScene = { ...this.scene }\n        this.$emit('update:scene', localScene)\n        this.action.linking = false\n        this.draggingLink = null\n\n        // add new Link\n        if (this.draggingLink && this.draggingLink.from !== index) {\n          // check link existence\n          const existed = this.scene.links.find((link) => {\n            return link.from === this.draggingLink.from && link.to === index;\n          })\n          if (!existed) {\n            let maxID = Math.max(0, ...this.scene.links.map((link) => {\n              return link.id\n            }))\n            const newLink = {\n              id: maxID + 1,\n              from: this.draggingLink.from,\n              to: index,\n            };\n            this.scene.links.push(newLink)\n            this.$emit('linkAdded', newLink)\n          }\n        }\n        this.draggingLink = null\n      },\n\n      linkDelete(id) {\n        const deletedLink = this.scene.links.find((item) => {\n          return item.id === id;\n        });\n        if (deletedLink) {\n          this.$emit('update:scene', {\n            ...this.scene,\n            links: this.scene.links.filter((item) => {\n              return item.id !== id;\n            })\n          });\n          this.$emit('linkBreak', deletedLink);\n        }\n      },\n\n    //   linkDelete(id) {\n    //     const deletedLink = this.scene.links.find((item) => {\n    //         return item.id === id;\n    //     });\n    //     if (deletedLink) {\n    //       this.scene.links = this.scene.links.filter((item) => {\n    //           return item.id !== id;\n    //       });\n    //       this.$emit('linkBreak', deletedLink);\n    //     }\n    //   },\n\n      nodeSelected(id, e) {\n        this.action.dragging = id;\n        this.action.selected = id;\n        this.$emit('nodeClick', id);\n        this.mouse.lastX = e.pageX || e.clientX + document.documentElement.scrollLeft\n        this.mouse.lastY = e.pageY || e.clientY + document.documentElement.scrollTop\n      },\n      handleMove(e) {\n        if (this.action.linking) {\n          [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n          [this.draggingLink.mx, this.draggingLink.my] = [this.mouse.x, this.mouse.y];\n        }\n        if (this.action.dragging) {\n          this.mouse.x = e.pageX || e.clientX + document.documentElement.scrollLeft\n          this.mouse.y = e.pageY || e.clientY + document.documentElement.scrollTop\n          let diffX = this.mouse.x - this.mouse.lastX;\n          let diffY = this.mouse.y - this.mouse.lastY;\n  \n          this.mouse.lastX = this.mouse.x;\n          this.mouse.lastY = this.mouse.y;\n          this.moveSelectedNode(diffX, diffY);\n        }\n        if (this.action.scrolling) {\n          [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n          let diffX = this.mouse.x - this.mouse.lastX;\n          let diffY = this.mouse.y - this.mouse.lastY;\n  \n          this.mouse.lastX = this.mouse.x;\n          this.mouse.lastY = this.mouse.y;\n          \n          this.$emit('update:scene', {\n            ...this.scene,\n            centerX: this.scene.centerX + diffX,\n            centerY: this.scene.centerY + diffY,\n          });\n\n        //   this.scene.centerX += diffX;\n        //   this.scene.centerY += diffY;\n  \n          // this.hasDragged = true\n        }\n      },\n      handleUp(e) {\n        const target = e.target || e.srcElement;\n        if (this.$el.contains(target)) {\n          if (typeof target.className !== 'string' || target.className.indexOf('node-input') < 0) {\n            this.draggingLink = null;\n          }\n          if (typeof target.className === 'string' && target.className.indexOf('node-delete') > -1) {\n            // console.log('delete2', this.action.dragging);\n            this.nodeDelete(this.action.dragging);\n          }\n        }\n        this.action.linking = false;\n        this.action.dragging = null;\n        this.action.scrolling = false;\n      },\n      handleDown(e) {\n        const target = e.target || e.srcElement;\n        // console.log('for scroll', target, e.keyCode, e.which)\n        if ((target === this.$el || target.matches('svg, svg *')) && e.which === 1) {\n          this.action.scrolling = true;\n          [this.mouse.lastX, this.mouse.lastY] = getMousePosition(this.$el, e);\n          this.action.selected = null; // deselectAll\n        }\n        this.$emit('canvasClick', e);\n      },\n      moveSelectedNode(dx, dy) {\n        let index = this.scene.nodes.findIndex((item) => {\n          return item.id === this.action.dragging\n        })\n        let left = this.scene.nodes[index].x + dx / this.scene.scale;\n        let top = this.scene.nodes[index].y + dy / this.scene.scale;\n        this.$set(this.scene.nodes, index, Object.assign(this.scene.nodes[index], {\n          x: left,\n          y: top,\n        }));\n      },\n\n      nodeDelete(id) {\n  this.$emit('update:scene', {\n    nodes: this.scene.nodes.filter((node) => {\n      return node.id !== id;\n    }),\n    links: this.scene.links.filter((link) => {\n      return link.from !== id && link.to !== id\n    })\n  })\n}\n    //   nodeDelete(id) {\n    //     this.scene.nodes = this.scene.nodes.filter((node) => {\n    //       return node.id !== id;\n    //     })\n    //     this.scene.links = this.scene.links.filter((link) => {\n    //       return link.from !== id && link.to !== id\n    //     })\n    //     this.$emit('nodeDelete', id)\n    //   }\n    },\n    watch: {\n      scene: {\n        handler(newScene) {\n          this.localScene = { ...newScene }\n        },\n        deep: true\n      }\n    }\n  }\n  </script>\n  \n  <!-- Add \"scoped\" attribute to limit CSS to this component only -->\n  <style scoped lang=\"scss\">\n  .flowchart-container {\n    margin: 0;\n    background: #ddd;\n    position: relative;\n    overflow: hidden;\n  }\n  </style>\n  \n\n"],"mappings":";mBAAA;;;;uBACIA,mBAAA,CAmBM;IAnBDC,KAAK,EAAC,qBAAqB;IAC7BC,WAAS,EAAAC,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAC,UAAA,IAAAD,QAAA,CAAAC,UAAA,IAAAF,IAAA,CAAU;IACrBG,SAAO,EAAAJ,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAG,QAAA,IAAAH,QAAA,CAAAG,QAAA,IAAAJ,IAAA,CAAQ;IACjBK,WAAS,EAAAN,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAK,UAAA,IAAAL,QAAA,CAAAK,UAAA,IAAAN,IAAA,CAAU;qBACtBJ,mBAAA,CAMM;IANDW,KAAK,EAAC,MAAM;IAAEC,MAAM,KAAKC,MAAA,CAAAD,MAAM;yBAClCZ,mBAAA,CAIiBc,SAAA,QAVzBC,WAAA,CAOkCV,QAAA,CAAAW,KAAK,EAPvC,CAOkBC,IAAI,EAAEC,KAAK;yBADrBC,YAAA,CAIiBC,yBAAA;MAJAH,IAAI,EAAEA,IAAI;MAExBI,GAAG,SAASH,KAAK;MACjBI,YAAU,EAAAC,MAAA,IAAElB,QAAA,CAAAmB,UAAU,CAACP,IAAI,CAACQ,EAAE;;kDATzCC,UAAA,K,kBAYM1B,mBAAA,CAOiBc,SAAA,QAnBvBC,WAAA,CAY8CF,MAAA,CAAAc,KAAK,CAACC,KAAK,EAZzD,CAY8BC,IAAI,EAAEX,KAAK;yBAAnCC,YAAA,CAOiBW,yBAAA;MANdT,GAAG,SAASH,KAAK;MACjBW,IAAI,EAAEA,IAAI;MACVE,OAAO,EAAE1B,QAAA,CAAA2B,WAAW;MACpBC,cAAY,EAAAV,MAAA,IAAElB,QAAA,CAAA6B,YAAY,CAACL,IAAI,CAACJ,EAAE;MAClCU,aAAW,EAAAZ,MAAA,IAAElB,QAAA,CAAA+B,WAAW,CAACP,IAAI,CAACJ,EAAE;MAChCY,cAAY,EAAAd,MAAA,IAAElB,QAAA,CAAAiC,YAAY,CAACT,IAAI,CAACJ,EAAE,EAAEF,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}