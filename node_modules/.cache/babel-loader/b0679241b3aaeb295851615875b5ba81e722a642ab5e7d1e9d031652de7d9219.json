{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport FlowchartLink from './FlowchartLink.vue';\nimport FlowchartNode from './FlowchartNode.vue';\nimport { getMousePosition } from '../assets/utility/position.js';\nexport default {\n  name: 'VueFlowchart',\n  props: {\n    scene: {\n      //scene: Object,\n      type: Object,\n      default() {\n        return {\n          centerX: 1024,\n          scale: 1,\n          centerY: 140,\n          nodes: [],\n          links: []\n        };\n      }\n    },\n    height: {\n      type: Number,\n      default: 400\n    }\n  },\n  data() {\n    return {\n      //localScene: { ...this.scene }, // create a local copy of the props\n      localScene: JSON.parse(JSON.stringify(this.scene)),\n      action: {\n        linking: false,\n        dragging: false,\n        scrolling: false,\n        selected: 0\n      },\n      mouse: {\n        x: 0,\n        y: 0,\n        lastX: 0,\n        lastY: 0\n      },\n      draggingLink: null,\n      rootDivOffset: {\n        top: 0,\n        left: 0\n      }\n    };\n  },\n  components: {\n    FlowchartLink,\n    FlowchartNode\n  },\n  computed: {\n    nodeOptions() {\n      return {\n        centerY: this.scene.centerY,\n        centerX: this.scene.centerX,\n        scale: this.scene.scale,\n        offsetTop: this.rootDivOffset.top,\n        offsetLeft: this.rootDivOffset.left,\n        selected: this.action.selected\n      };\n    },\n    lines() {\n      const lines = this.scene.links.map(link => {\n        const fromNode = this.findNodeWithID(link.from);\n        const toNode = this.findNodeWithID(link.to);\n        let x, y, cy, cx, ex, ey;\n        x = this.scene.centerX + fromNode.x;\n        y = this.scene.centerY + fromNode.y;\n        [cx, cy] = this.getPortPosition('bottom', x, y);\n        x = this.scene.centerX + toNode.x;\n        y = this.scene.centerY + toNode.y;\n        [ex, ey] = this.getPortPosition('top', x, y);\n        return {\n          start: [cx, cy],\n          end: [ex, ey],\n          id: link.id\n        };\n      });\n      if (this.draggingLink) {\n        let x, y, cy, cx;\n        const fromNode = this.findNodeWithID(this.draggingLink.from);\n        x = this.scene.centerX + fromNode.x;\n        y = this.scene.centerY + fromNode.y;\n        [cx, cy] = this.getPortPosition('bottom', x, y);\n        // push temp dragging link, mouse cursor postion = link end postion \n        lines.push({\n          start: [cx, cy],\n          end: [this.draggingLink.mx, this.draggingLink.my]\n        });\n      }\n      return lines;\n    },\n    localSceneCopy() {\n      return {\n        ...this.scene\n      }; // create a local copy of the prop\n    }\n  },\n  mounted() {\n    this.rootDivOffset.top = this.$el ? this.$el.offsetTop : 0;\n    this.rootDivOffset.left = this.$el ? this.$el.offsetLeft : 0;\n    // console.log(22222, this.rootDivOffset);\n  },\n  methods: {\n    findNodeWithID(id) {\n      return this.scene.nodes.find(item => {\n        return id === item.id;\n      });\n    },\n    getPortPosition(type, x, y) {\n      if (type === 'top') {\n        return [x + 40, y];\n      } else if (type === 'bottom') {\n        return [x + 40, y + 80];\n      }\n    },\n    linkingStart(index) {\n      this.action.linking = true;\n      this.draggingLink = {\n        from: index,\n        mx: 0,\n        my: 0\n      };\n    },\n    linkingStop(index) {\n      const localScene = {\n        ...this.scene\n      };\n      this.$emit('update:scene', localScene);\n      this.action.linking = false;\n      this.draggingLink = null;\n\n      // add new Link\n      if (this.draggingLink && this.draggingLink.from !== index) {\n        // check link existence\n        const existed = this.scene.links.find(link => {\n          return link.from === this.draggingLink.from && link.to === index;\n        });\n        if (!existed) {\n          let maxID = Math.max(0, ...this.scene.links.map(link => {\n            return link.id;\n          }));\n          const newLink = {\n            id: maxID + 1,\n            from: this.draggingLink.from,\n            to: index\n          };\n          this.scene.links.push(newLink);\n          this.$emit('linkAdded', newLink);\n        }\n      }\n      this.draggingLink = null;\n    },\n    linkDelete(id) {\n      const deletedLink = this.scene.links.find(item => {\n        return item.id === id;\n      });\n      if (deletedLink) {\n        this.$emit('update:scene', {\n          ...this.scene,\n          links: this.scene.links.filter(item => {\n            return item.id !== id;\n          })\n        });\n        this.$emit('linkBreak', deletedLink);\n      }\n    },\n    //   linkDelete(id) {\n    //     const deletedLink = this.scene.links.find((item) => {\n    //         return item.id === id;\n    //     });\n    //     if (deletedLink) {\n    //       this.scene.links = this.scene.links.filter((item) => {\n    //           return item.id !== id;\n    //       });\n    //       this.$emit('linkBreak', deletedLink);\n    //     }\n    //   },\n\n    nodeSelected(id, e) {\n      this.action.dragging = id;\n      this.action.selected = id;\n      this.$emit('nodeClick', id);\n      this.mouse.lastX = e.pageX || e.clientX + document.documentElement.scrollLeft;\n      this.mouse.lastY = e.pageY || e.clientY + document.documentElement.scrollTop;\n    },\n    handleMove(e) {\n      if (this.action.linking) {\n        [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n        [this.draggingLink.mx, this.draggingLink.my] = [this.mouse.x, this.mouse.y];\n      }\n      if (this.action.dragging) {\n        this.mouse.x = e.pageX || e.clientX + document.documentElement.scrollLeft;\n        this.mouse.y = e.pageY || e.clientY + document.documentElement.scrollTop;\n        let diffX = this.mouse.x - this.mouse.lastX;\n        let diffY = this.mouse.y - this.mouse.lastY;\n        this.mouse.lastX = this.mouse.x;\n        this.mouse.lastY = this.mouse.y;\n        this.moveSelectedNode(diffX, diffY);\n      }\n      if (this.action.scrolling) {\n        [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n        let diffX = this.mouse.x - this.mouse.lastX;\n        let diffY = this.mouse.y - this.mouse.lastY;\n        this.mouse.lastX = this.mouse.x;\n        this.mouse.lastY = this.mouse.y;\n        this.$emit('update:scene', {\n          ...this.scene,\n          centerX: this.scene.centerX + diffX,\n          centerY: this.scene.centerY + diffY\n        });\n\n        //   this.scene.centerX += diffX;\n        //   this.scene.centerY += diffY;\n\n        // this.hasDragged = true\n      }\n    },\n    handleUp(e) {\n      const target = e.target || e.srcElement;\n      if (this.$el.contains(target)) {\n        if (typeof target.className !== 'string' || target.className.indexOf('node-input') < 0) {\n          this.draggingLink = null;\n        }\n        if (typeof target.className === 'string' && target.className.indexOf('node-delete') > -1) {\n          // console.log('delete2', this.action.dragging);\n          this.nodeDelete(this.action.dragging);\n        }\n      }\n      this.action.linking = false;\n      this.action.dragging = null;\n      this.action.scrolling = false;\n    },\n    handleDown(e) {\n      const target = e.target || e.srcElement;\n      // console.log('for scroll', target, e.keyCode, e.which)\n      if ((target === this.$el || target.matches('svg, svg *')) && e.which === 1) {\n        this.action.scrolling = true;\n        [this.mouse.lastX, this.mouse.lastY] = getMousePosition(this.$el, e);\n        this.action.selected = null; // deselectAll\n      }\n      this.$emit('canvasClick', e);\n    },\n    moveSelectedNode(dx, dy) {\n      let index = this.scene.nodes.findIndex(item => {\n        return item.id === this.action.dragging;\n      });\n      let left = this.scene.nodes[index].x + dx / this.scene.scale;\n      let top = this.scene.nodes[index].y + dy / this.scene.scale;\n      this.$set(this.scene.nodes, index, Object.assign(this.scene.nodes[index], {\n        x: left,\n        y: top\n      }));\n    },\n    nodeDelete(id) {\n      this.localScene.nodes = this.localScene.nodes.filter(node => {\n        return node.id !== id;\n      });\n      this.localScene.links = this.localScene.links.filter(link => {\n        return link.from !== id && link.to !== id;\n      });\n      this.$emit('update:scene', this.localScene);\n    }\n    // nodeDelete(id) {\n    //   const localScene = JSON.parse(JSON.stringify(this.scene));\n    //   localScene.nodes = localScene.nodes.filter((node) => {\n    //     return node.id !== id;\n    //   });\n    //   localScene.links = localScene.links.filter((link) => {\n    //     return link.from !== id && link.to !== id\n    //   })\n    //   this.$emit('update:scene', localScene)\n    // }      \n\n    // nodeDelete(id) {\n    //   const localScene = { ...this.localScene }\n    //   localScene.nodes = localScene.nodes.filter((node) => {\n    //     return node.id !== id;\n    //   });\n    //   localScene.links = localScene.links.filter((link) => {\n    //     return link.from !== id && link.to !== id\n    //   })\n    //   this.$emit('update:scene', localScene)\n    // }\n\n    // nodeDelete(id) {\n    //   this.$emit('update:scene', {\n    //     nodes: this.scene.nodes.filter((node) => {\n    //       return node.id !== id;\n    //     }),\n    //     links: this.scene.links.filter((link) => {\n    //       return link.from !== id && link.to !== id\n    //     })\n    //   })\n    // }\n\n    //   nodeDelete(id) {\n    //     this.scene.nodes = this.scene.nodes.filter((node) => {\n    //       return node.id !== id;\n    //     })\n    //     this.scene.links = this.scene.links.filter((link) => {\n    //       return link.from !== id && link.to !== id\n    //     })\n    //     this.$emit('nodeDelete', id)\n    //   }\n  },\n  watch: {\n    scene: {\n      handler(newScene) {\n        this.localSceneCopy = {\n          ...newScene\n        };\n      },\n      deep: true\n    }\n  }\n};","map":{"version":3,"names":["FlowchartLink","FlowchartNode","getMousePosition","name","props","scene","type","Object","default","centerX","scale","centerY","nodes","links","height","Number","data","localScene","JSON","parse","stringify","action","linking","dragging","scrolling","selected","mouse","x","y","lastX","lastY","draggingLink","rootDivOffset","top","left","components","computed","nodeOptions","offsetTop","offsetLeft","lines","map","link","fromNode","findNodeWithID","from","toNode","to","cy","cx","ex","ey","getPortPosition","start","end","id","push","mx","my","localSceneCopy","mounted","$el","methods","find","item","linkingStart","index","linkingStop","$emit","existed","maxID","Math","max","newLink","linkDelete","deletedLink","filter","nodeSelected","e","pageX","clientX","document","documentElement","scrollLeft","pageY","clientY","scrollTop","handleMove","diffX","diffY","moveSelectedNode","handleUp","target","srcElement","contains","className","indexOf","nodeDelete","handleDown","matches","which","dx","dy","findIndex","$set","assign","node","watch","handler","newScene","deep"],"sources":["/Users/kerinwong/Documents/VSCode_tutorial/my-simple-flowchart/src/components/SimpleFlowchart.vue"],"sourcesContent":["<template>\n    <div class=\"flowchart-container\" \n      @mousemove=\"handleMove\" \n      @mouseup=\"handleUp\"\n      @mousedown=\"handleDown\">\n      <svg width=\"100%\" :height=\"`${height}px`\">\n        <flowchart-link :link=\"link\"\n          v-for=\"(link, index) in lines\" \n          :key=\"`link${index}`\"\n          @deleteLink=\"linkDelete(link.id)\">\n        </flowchart-link>\n      </svg>\n      <flowchart-node v-for=\"(node, index) in scene.nodes\" \n        :key=\"`node${index}`\"\n        :node=\"node\" \n        :options=\"nodeOptions\"\n        @linkingStart=\"linkingStart(node.id)\"\n        @linkingStop=\"linkingStop(node.id)\"\n        @nodeSelected=\"nodeSelected(node.id, $event)\">\n      </flowchart-node>\n    </div>\n  </template>\n  \n  <script>\n  import FlowchartLink from './FlowchartLink.vue';\n  import FlowchartNode from './FlowchartNode.vue';\n  import { getMousePosition } from '../assets/utility/position.js';\n  \n  export default {\n    name: 'VueFlowchart',\n    props: {\n      scene: {\n        //scene: Object,\n        type: Object,\n        default() {\n          return {\n            centerX: 1024,\n            scale: 1,\n            centerY: 140,\n            nodes: [],\n            links: [],\n          }\n        }\n      },\n      height: {\n        type: Number,\n        default: 400,\n      },\n    },\n    data() {\n      return {\n        //localScene: { ...this.scene }, // create a local copy of the props\n        localScene: JSON.parse(JSON.stringify(this.scene)),\n        action: {\n          linking: false,\n          dragging: false,\n          scrolling: false,\n          selected: 0,\n        },\n        mouse: {\n          x: 0,\n          y: 0,\n          lastX: 0,\n          lastY: 0,\n        },\n        draggingLink: null,\n        rootDivOffset: {\n          top: 0,\n          left: 0\n        },\n      };\n    },\n    components: {\n      FlowchartLink,\n      FlowchartNode,\n    },\n    computed: {\n      nodeOptions() {\n        return {\n          centerY: this.scene.centerY,\n          centerX: this.scene.centerX,\n          scale: this.scene.scale,\n          offsetTop: this.rootDivOffset.top,\n          offsetLeft: this.rootDivOffset.left,\n          selected: this.action.selected,\n        }\n      },\n      lines() {\n        const lines = this.scene.links.map((link) => {\n          const fromNode = this.findNodeWithID(link.from)\n          const toNode = this.findNodeWithID(link.to)\n          let x, y, cy, cx, ex, ey;\n          x = this.scene.centerX + fromNode.x;\n          y = this.scene.centerY + fromNode.y;\n          [cx, cy] = this.getPortPosition('bottom', x, y);\n          x = this.scene.centerX + toNode.x;\n          y = this.scene.centerY + toNode.y;\n          [ex, ey] = this.getPortPosition('top', x, y);\n          return { \n            start: [cx, cy], \n            end: [ex, ey],\n            id: link.id,\n          };\n        })\n        if (this.draggingLink) {\n          let x, y, cy, cx;\n          const fromNode = this.findNodeWithID(this.draggingLink.from)\n          x = this.scene.centerX + fromNode.x;\n          y = this.scene.centerY + fromNode.y;\n          [cx, cy] = this.getPortPosition('bottom', x, y);\n          // push temp dragging link, mouse cursor postion = link end postion \n          lines.push({ \n            start: [cx, cy], \n            end: [this.draggingLink.mx, this.draggingLink.my],\n          })\n        }\n        return lines;\n      },\n      localSceneCopy() {\n        return { ...this.scene } // create a local copy of the prop\n      }\n    },\n    mounted() {\n      this.rootDivOffset.top = this.$el ? this.$el.offsetTop : 0;\n      this.rootDivOffset.left = this.$el ? this.$el.offsetLeft : 0;\n      // console.log(22222, this.rootDivOffset);\n    },\n    methods: {\n      findNodeWithID(id) {\n        return this.scene.nodes.find((item) => {\n            return id === item.id\n        })\n      },\n      getPortPosition(type, x, y) {\n        if (type === 'top') {\n          return [x + 40, y];\n        }\n        else if (type === 'bottom') {\n          return [x + 40, y + 80];\n        }\n      },\n      linkingStart(index) {\n        this.action.linking = true;\n        this.draggingLink = {\n          from: index,\n          mx: 0,\n          my: 0,\n        };\n      },\n      linkingStop(index) {\n        const localScene = { ...this.scene }\n        this.$emit('update:scene', localScene)\n        this.action.linking = false\n        this.draggingLink = null\n\n        // add new Link\n        if (this.draggingLink && this.draggingLink.from !== index) {\n          // check link existence\n          const existed = this.scene.links.find((link) => {\n            return link.from === this.draggingLink.from && link.to === index;\n          })\n          if (!existed) {\n            let maxID = Math.max(0, ...this.scene.links.map((link) => {\n              return link.id\n            }))\n            const newLink = {\n              id: maxID + 1,\n              from: this.draggingLink.from,\n              to: index,\n            };\n            this.scene.links.push(newLink)\n            this.$emit('linkAdded', newLink)\n          }\n        }\n        this.draggingLink = null\n      },\n\n      linkDelete(id) {\n        const deletedLink = this.scene.links.find((item) => {\n          return item.id === id;\n        });\n        if (deletedLink) {\n          this.$emit('update:scene', {\n            ...this.scene,\n            links: this.scene.links.filter((item) => {\n              return item.id !== id;\n            })\n          });\n          this.$emit('linkBreak', deletedLink);\n        }\n      },\n\n    //   linkDelete(id) {\n    //     const deletedLink = this.scene.links.find((item) => {\n    //         return item.id === id;\n    //     });\n    //     if (deletedLink) {\n    //       this.scene.links = this.scene.links.filter((item) => {\n    //           return item.id !== id;\n    //       });\n    //       this.$emit('linkBreak', deletedLink);\n    //     }\n    //   },\n\n      nodeSelected(id, e) {\n        this.action.dragging = id;\n        this.action.selected = id;\n        this.$emit('nodeClick', id);\n        this.mouse.lastX = e.pageX || e.clientX + document.documentElement.scrollLeft\n        this.mouse.lastY = e.pageY || e.clientY + document.documentElement.scrollTop\n      },\n      handleMove(e) {\n        if (this.action.linking) {\n          [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n          [this.draggingLink.mx, this.draggingLink.my] = [this.mouse.x, this.mouse.y];\n        }\n        if (this.action.dragging) {\n          this.mouse.x = e.pageX || e.clientX + document.documentElement.scrollLeft\n          this.mouse.y = e.pageY || e.clientY + document.documentElement.scrollTop\n          let diffX = this.mouse.x - this.mouse.lastX;\n          let diffY = this.mouse.y - this.mouse.lastY;\n  \n          this.mouse.lastX = this.mouse.x;\n          this.mouse.lastY = this.mouse.y;\n          this.moveSelectedNode(diffX, diffY);\n        }\n        if (this.action.scrolling) {\n          [this.mouse.x, this.mouse.y] = getMousePosition(this.$el, e);\n          let diffX = this.mouse.x - this.mouse.lastX;\n          let diffY = this.mouse.y - this.mouse.lastY;\n  \n          this.mouse.lastX = this.mouse.x;\n          this.mouse.lastY = this.mouse.y;\n          \n          this.$emit('update:scene', {\n            ...this.scene,\n            centerX: this.scene.centerX + diffX,\n            centerY: this.scene.centerY + diffY,\n          });\n\n        //   this.scene.centerX += diffX;\n        //   this.scene.centerY += diffY;\n  \n          // this.hasDragged = true\n        }\n      },\n      handleUp(e) {\n        const target = e.target || e.srcElement;\n        if (this.$el.contains(target)) {\n          if (typeof target.className !== 'string' || target.className.indexOf('node-input') < 0) {\n            this.draggingLink = null;\n          }\n          if (typeof target.className === 'string' && target.className.indexOf('node-delete') > -1) {\n            // console.log('delete2', this.action.dragging);\n            this.nodeDelete(this.action.dragging);\n          }\n        }\n        this.action.linking = false;\n        this.action.dragging = null;\n        this.action.scrolling = false;\n      },\n      handleDown(e) {\n        const target = e.target || e.srcElement;\n        // console.log('for scroll', target, e.keyCode, e.which)\n        if ((target === this.$el || target.matches('svg, svg *')) && e.which === 1) {\n          this.action.scrolling = true;\n          [this.mouse.lastX, this.mouse.lastY] = getMousePosition(this.$el, e);\n          this.action.selected = null; // deselectAll\n        }\n        this.$emit('canvasClick', e);\n      },\n      moveSelectedNode(dx, dy) {\n        let index = this.scene.nodes.findIndex((item) => {\n          return item.id === this.action.dragging\n        })\n        let left = this.scene.nodes[index].x + dx / this.scene.scale;\n        let top = this.scene.nodes[index].y + dy / this.scene.scale;\n        this.$set(this.scene.nodes, index, Object.assign(this.scene.nodes[index], {\n          x: left,\n          y: top,\n        }));\n      },\n      nodeDelete(id) {\n        this.localScene.nodes = this.localScene.nodes.filter((node) => {\n          return node.id !== id;\n        });\n        this.localScene.links = this.localScene.links.filter((link) => {\n          return link.from !== id && link.to !== id\n        })\n        this.$emit('update:scene', this.localScene)\n      }\n    // nodeDelete(id) {\n    //   const localScene = JSON.parse(JSON.stringify(this.scene));\n    //   localScene.nodes = localScene.nodes.filter((node) => {\n    //     return node.id !== id;\n    //   });\n    //   localScene.links = localScene.links.filter((link) => {\n    //     return link.from !== id && link.to !== id\n    //   })\n    //   this.$emit('update:scene', localScene)\n    // }      \n\n        // nodeDelete(id) {\n        //   const localScene = { ...this.localScene }\n        //   localScene.nodes = localScene.nodes.filter((node) => {\n        //     return node.id !== id;\n        //   });\n        //   localScene.links = localScene.links.filter((link) => {\n        //     return link.from !== id && link.to !== id\n        //   })\n        //   this.$emit('update:scene', localScene)\n        // }\n\n        // nodeDelete(id) {\n        //   this.$emit('update:scene', {\n        //     nodes: this.scene.nodes.filter((node) => {\n        //       return node.id !== id;\n        //     }),\n        //     links: this.scene.links.filter((link) => {\n        //       return link.from !== id && link.to !== id\n        //     })\n        //   })\n        // }\n\n    //   nodeDelete(id) {\n    //     this.scene.nodes = this.scene.nodes.filter((node) => {\n    //       return node.id !== id;\n    //     })\n    //     this.scene.links = this.scene.links.filter((link) => {\n    //       return link.from !== id && link.to !== id\n    //     })\n    //     this.$emit('nodeDelete', id)\n    //   }\n    },\n    watch: {\n    scene: {\n      handler(newScene) {\n        this.localSceneCopy = { ...newScene }\n      },\n      deep: true\n    }\n  }\n  }\n  </script>\n  \n  <!-- Add \"scoped\" attribute to limit CSS to this component only -->\n  <style scoped lang=\"scss\">\n  .flowchart-container {\n    margin: 0;\n    background: #ddd;\n    position: relative;\n    overflow: hidden;\n  }\n  </style>\n  \n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}